package com.example.blockchainjava.Model.DAO;

import com.example.blockchainjava.Model.Block.Block;
import com.example.blockchainjava.Model.Transaction.Transaction;
import com.example.blockchainjava.Model.Transaction.TransactionStatus;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class BlockDAO {
    private final Connection connection;

    public BlockDAO() {
        this.connection = DatabaseConnection.getConnection();
    }

    public void saveBlock(Block block) {
        // SQL query excluding the blockId because it will be auto-generated by the database
        String sql = "INSERT INTO blocks (previous_hash, current_hash, timestamp, validator_signature) VALUES (?, ?, ?, ?)";

        try (PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, block.getPreviousHash());
            stmt.setString(2, block.getCurrentHash());
            stmt.setTimestamp(3, Timestamp.valueOf(block.getTimestamp()));
            stmt.setString(4, block.getValidatorSignature());

            stmt.executeUpdate();

            // Retrieve the auto-generated blockId (the primary key that was auto-incremented)
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) {
                    // Set the auto-generated blockId in the Block object
                    block.setBlockId(rs.getInt(1));  // The first column contains the generated blockId
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to save block", e);
        }
    }

    public int getLastBlockId() {
        String sql = "SELECT MAX(id) AS last_id FROM blocks";

        try (PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {

            if (rs.next()) {
                // Retourne l'ID du dernier bloc, ou null si la table est vide
                return rs.getInt("last_id");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to get last block ID", e);
        }

        return 0;  // Si aucun bloc n'existe, retourne 0 ou une autre valeur de votre choix
    }

    public List<Block> getAllBlocks() {
        List<Block> blocks = new ArrayList<>();
        String sql = "SELECT b.*, t.* FROM blocks b " +
                "LEFT JOIN transactions t ON b.id = t.block_id " +
                "ORDER BY b.id";

        try (PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {

            while (rs.next()) {
                // Récupérer les données de la transaction avec gestion des valeurs nulles
                Timestamp createdAtTimestamp = rs.getTimestamp("created_at");
                LocalDateTime createdAt = createdAtTimestamp != null ? createdAtTimestamp.toLocalDateTime() : LocalDateTime.now();

                Transaction transaction = new Transaction(
                        rs.getInt("t.id"),
                        rs.getInt("sender_id"),
                        rs.getString("receiver_key"),
                        rs.getDouble("amount"),
                        rs.getString("status") != null ? TransactionStatus.valueOf(rs.getString("status")) : TransactionStatus.PENDING,
                        rs.getInt("block_id"),
                        createdAt
                );
                transaction.setSignature(rs.getString("signature"));

                // Récupérer les données du bloc avec gestion des valeurs nulles
                Timestamp blockTimestamp = rs.getTimestamp("timestamp");
                LocalDateTime blockTimestampConverted = blockTimestamp != null ? blockTimestamp.toLocalDateTime() : LocalDateTime.now();

                Block block = new Block(
                        rs.getInt("b.id"),
                        rs.getString("previous_hash"),
                        transaction,
                        rs.getString("validator_signature"),
                        blockTimestampConverted,
                        rs.getString("current_hash")
                );
                block.setBlockId(rs.getInt("id"));
                block.setCurrentHash(rs.getString("current_hash"));
                block.setTimestamp(blockTimestampConverted);

                blocks.add(block);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to load blocks", e);
        }

        return blocks;
    }
    public void updateBlock(Block block) {
        String sql = "UPDATE blocks SET previous_hash = ?, current_hash = ?, validator_signature = ? WHERE id = ?";

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            // Remplir les paramètres de la requête
            stmt.setString(1, block.getPreviousHash());
            stmt.setString(2, block.getCurrentHash());
            stmt.setString(3, block.getValidatorSignature());
            stmt.setInt(4, block.getBlockId());

            int rowsUpdated = stmt.executeUpdate();

            if (rowsUpdated > 0) {
                System.out.println("Bloc ID " + block.getBlockId() + " mis à jour avec succès.");
            } else {
                System.out.println("Aucun bloc trouvé avec l'ID " + block.getBlockId() + ". Mise à jour échouée.");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Erreur lors de la mise à jour du bloc ID " + block.getBlockId(), e);
        }
    }


}
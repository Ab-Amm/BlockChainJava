package com.example.blockchainjava.Model.DAO;

import com.example.blockchainjava.Model.Block.Block;
import com.example.blockchainjava.Model.Transaction.Transaction;
import com.example.blockchainjava.Model.Transaction.TransactionStatus;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class BlockDAO {
    private final Connection connection;

    public BlockDAO() {
        this.connection = DatabaseConnection.getConnection();
    }

    public void saveBlock(Block block) {
        // SQL query excluding the blockId because it will be auto-generated by the database
        String sql = "INSERT INTO blocks (previous_hash, current_hash, timestamp, validator_signature) VALUES (?, ?, ?, ?)";

        try (PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setString(1, block.getPreviousHash());
            stmt.setString(2, block.getCurrentHash());
            stmt.setTimestamp(3, Timestamp.valueOf(block.getTimestamp()));
            stmt.setString(4, block.getValidatorSignature());

            stmt.executeUpdate();

            // Retrieve the auto-generated blockId (the primary key that was auto-incremented)
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) {
                    // Set the auto-generated blockId in the Block object
                    block.setBlockId(rs.getInt(1));  // The first column contains the generated blockId
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to save block", e);
        }
    }

    public int getLastBlockId() {
        String sql = "SELECT MAX(id) AS last_id FROM blocks";

        try (PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {

            if (rs.next()) {
                // Retourne l'ID du dernier bloc, ou null si la table est vide
                return rs.getInt("last_id");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to get last block ID", e);
        }

        return 0;  // Si aucun bloc n'existe, retourne 0 ou une autre valeur de votre choix
    }

    public List<Block> getAllBlocks() {
        List<Block> blocks = new ArrayList<>();
        String sql = "SELECT b.*, t.* FROM blocks b " +
                "LEFT JOIN transactions t ON b.id = t.block_id " +
                "ORDER BY b.id";

        try (PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {

            while (rs.next()) {
                Transaction transaction = new Transaction(
                        rs.getInt("t.id"),
                        rs.getInt("sender_id"),
                        rs.getString("receiver_key"),
                        rs.getDouble("amount"),
                        rs.getString("status") != null ? TransactionStatus.valueOf(rs.getString("status")) : TransactionStatus.PENDING,
                        rs.getInt("block_id"),
                        rs.getTimestamp("created_at") != null ? rs.getTimestamp("created_at").toLocalDateTime() : LocalDateTime.now()
                );
                transaction.setSignature(rs.getString("signature"));
                Block block = new Block(
                        rs.getInt("b.id"),
                        rs.getString("previous_hash"),
                        transaction,
                        rs.getString("validator_signature")
                );
                block.setBlockId(rs.getInt("id"));
                block.setCurrentHash(rs.getString("current_hash"));
                block.setTimestamp(rs.getTimestamp("timestamp") != null ? rs.getTimestamp("timestamp").toLocalDateTime() : LocalDateTime.now());

                blocks.add(block);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to load blocks", e);
        }
        return blocks;
    }
}